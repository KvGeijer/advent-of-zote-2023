include!("stdlib");
include!("aoc.zote");

fn to_card(char, part2) -> 
	match char {
		'A' -> 14,
		'K' -> 13,
		'Q' -> 12,
		'J' -> if part2 (-1) else 11,
		'T' -> 10,
		char -> int(char),
	}

fn power(hand) -> {
	cd := hand 
		>> map(\card -> [card, hand >> filter(\>> eq(card)) >> len])
		>> dict;

	joker := if -1 >> in(cd) cd[-1] else 0;
	counts := [0, 0, 0, 0, 0, 0];
	for (c, count) in cd if c != -1 counts[count] += 1;

	if counts[5] or counts[4] and joker >= 1 or counts[3] and joker >= 2 or counts[2] and joker >= 3 or counts[1] and joker >= 4 or joker == 5 return 7
	else if counts[4] or counts[3] and joker >= 1 or counts[2] and joker >= 2 or counts[1] and joker >= 3 or joker == 4 return 6

	else if counts[3] and counts[2] return 5
	else if counts[2] == 2 and joker >= 1 or counts[3] and joker >= 1 return 5
	else if counts[2] == 1 and joker >= 3 return 5

	else if counts[3] or counts[2] and joker >= 1 or counts[1] and joker >= 2 or joker == 3 return 4 // three kind
	else if counts[2] == 2 or counts[2] and joker >= 1 or joker >= 2 return 3 // two pair
	else if counts[2] or joker >= 1 return 2 // pair
	else return 1;
}

fn rank(hand1, hand2) -> {
	(p1, p2) := [power(hand1), power(hand2)];
	if p1 > p2 
		1
	else if p2 > p1 
		(-1) // TODO: Annoying that we need some encapsulation for -1, as it will otherwise bind as p1 - 1
	else 
		for (c1, c2) in zip(hand1, hand2) 
			if c1 > c2 
				return 1
			else if c2 > c1
				return -1
}

for part2 in [false, true] {
	hands := read("input")
		>> split("\n") 
		>> map(\>> split(" ") >> (\(k, v) -> [map(k, \>> to_card(part2)), v])) 
		>> dict;
	
	hands_sorted := hands 
		>> list 
		>> sort(\(hand1, _), (hand2, _) -> rank(hand1, hand2)); 

	hands_sorted 
		>> enumerate 
		>> map(\(ind, (_, bid)) -> int(bid)*(ind+1)) 
		>> sum 
		>> print;
}




