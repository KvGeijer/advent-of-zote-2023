include!("stdlib");
include!("aoc.zote");

input := read("input") >> trim;
lines := input >> split("\n");

bricks := lines >> map(\>> split("~") >> map(\>> split(",") >> map(int) >> rev)) 
	// >> sort 
	>> map(\>> map(\>> rev)) >> enumerate;

bricks := bricks >> map(\(id, (p1, p2)) -> [id, p1, p2]);

fn between(p1, p2) -> {
	ps := [p2];
	for i in [0:3] if p1[i] != p2[i] for v in [p1[i]:p2[i]] {
		p := p1 >> clone;
		p[i] = v;
		p >> push(ps);
	}
	ps
}

// pos to id
positions := dict();
for (id, p1, p2) in bricks {
	for p in between(p1, p2) 
		positions[p] = id;
}

// return between([1, 0, 1], [1, 6, 1]);

vadd := \(x, y, z), (x2, y2, z2) -> [x + x2, y + y2, z + z2];

fn lower() -> {
	changed := set();
	next := dict();
	bricks_new := [];
	// print(positions);

	for (id, p1, p2) in bricks {
		p1n := p1 >> vadd([0,0,-1]);
		p2n := p2 >> vadd([0,0,-1]);

		// Will this brick (id) fall?
		ok := true;
		for p in between(p1n, p2n) {
			if p[2] < 1 or get_or(p, positions, id) > id or get_or(p, next, id) < id {
				ok = false;
				break;
			}
		}

		// Did it fall?
		if ok id >> insert(changed);
		// print("Change for id ", id, ", ", changed);
		
		if ok for p in between(p1n, p2n) {
			next[p] = id;
		}
		else for p in between(p1, p2) {
			next[p] = id;
		}

		if ok {
			[id, p1n, p2n] >> push(bricks_new);
		} else {
			[id, p1, p2] >> push(bricks_new);
			
		}
	}
	
	[next, bricks_new, changed]
}

// We need final position, as well as 
steps :=0;
while true {
	(next, bricks_new, change) := lower();
	if !change break;
	steps += 1;
	positions = next;
	bricks = bricks_new;
	print("Done with step ", steps);
}

// print(positions);
print("starting check");

fn fall_many() ->{
	t := set();
	while true {
		(next, bricks_new, change) := lower();
		if union(t, change) == t return len(t);
		t = t >> union(change);
		if !change return len(t);
		positions = next;
		bricks = bricks_new;
	}
}

tot := 0;
t2 := 0;
p_real := positions >> clone;
bricks_real := bricks >> clone;
for (id, p1, p2) in bricks {
	// print("----- Trying to remove ", id);
	positions = p_real >> list >> filter(\(_, id1) -> id1 != id) >> dict;
	bricks = bricks_real >> filter(\(id1, _, _) -> id1 != id);
	(next, bricks_new, changed) := lower();
	t2 += fall_many();
	// if changed print("Falling ", changed, " when dis ", id);
	print(id);
	// t2 += changed;
	// if !changed {
		// print("Ok ", id);
		// tot += 1;
	// }
}
print("Done");
print(t2);
